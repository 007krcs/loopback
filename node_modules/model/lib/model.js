/**
 * Expose `Model`.
 */

module.exports = Model;

/**
 * Module dependencies.
 */
 
var EventEmitter = require('events').EventEmitter
  , debug = require('debug')('model')
  , util = require('util')
  , inherits = util.inherits
  , assert = require('assert');
  
/**
 * Create a new `Model` with the given `options`.
 *
 * @param {Object} options
 * @return {Model}
 */

function Model(data) {
  EventEmitter.call(this);

  var ModelCtor = this.constructor;
  var schema = ModelCtor.schema;

  // get properties that match the schema
  var matchedProperties = schema.getMatchedProperties(data);

  // set properties that match the schema
  Object.keys(matchedProperties).forEach(function (property) {
    this[property] = matchedProperties[property];
  }.bind(this));
}

/**
 * Inherit from `EventEmitter`.
 */

inherits(Model, EventEmitter);

/**
 * Create a new Model class from the given options.
 *
 * @param options {Object}
 * @return {Model}
 */
 
Model.extend = function (options) {
  var Super = this;
  
  // the new constructor
  function Model() {
    Super.apply(this, arguments);
  }
  
  Model.options = options;
  
  assert(options.name, 'must provide a name when extending from model');
  
  // model namespace
  Model.namespace = options.name;
  
  // define the remote namespace
  Model.remoteNamespace = options.plural || pluralize(Model.namespace);
  
  // inherit all static methods
  Object.keys(Super).forEach(function (key) {
    if(typeof Super[key] === 'function') {
      MyModel[key] = Super[key];
    }
  });
  
  // inherit all other things
  inherits(MyModel, Super);
  
  return Model;
}

/**
 * Construct a model instance for remote use.
 */

Model.remoteConstructor = function (data, fn) {
  var ModelCtor = this;
  
  fn(null, new ModelCtor(data));
}

/**
 * Define the data the model represents using the data definition language.
 */

Model.defineSchema = function (schema) {
  throw new Error('not implemented');
}

/**
 * Set the data source for the model. Must provide a name of an existing data source.
 * If the namespace is not provided the plural model name (eg. colors) will be used.
 *
 * **Note:** If you do not set a data source or a map (or both) the default data source
 * will be used (an in memory database).
 */

Model.dataSource = function (dataSourceName, namespace) {
  namespace = namespace || this.namespace;
  throw new Error('not implemented');
}

/**
 * Define a mapping between the data source representation of your data and your app's representation.
 */

Model.defineMap = function (mapping) {
  // see: https://github.com/strongloop/asteroid/tree/master/node_modules/model#mymodeldefinemapmap
  throw new Error('not implemented');
}

/**
 * Using the mapped data source, try to discover the schema of a table or other namespace (url, collection, etc).
 */

Model.discoverSchema = function (fn) {
  throw new Error('not implemented');
}

/**
 * Fetch a model by id.
 */

Model.getById = function (id, fn) {
  var ModelCtor = this;
  var model = new ModelCtor({id: id});
  
  model.fetch(fn);
}
Model.getById.remotable = true;
Model.getById.returns = [
  {arg: 'model', 'type': 'this'}
];

/**
 * Fetch the model data and update the instance.
 *
 * **Note:** this is a remotable instance method.
 */

Model.prototype.fetch = function (fn) {
  throw new Error('not implemented');
}
Model.prototype.fetch.remotable = true;
Model.prototype.fetch.returns = [
  {arg: 'model', 'type': 'this'}
];

/**
 * Save the model data.
 *
 * **Note:** this is a remotable instance method.
 */

Model.prototype.save = function (fn) {
  throw new Error('not implemented');
}
Model.prototype.save.remotable = true;
Model.prototype.save.returns = [
  {arg: 'model', 'type': 'this'}
];

/**
 * Helper method for creating and saving models.
 */

Model.create = function (data, fn) {
  var ModelCtor = this;
  var model = new ModelCtor(data);
  
  model.save(fn);
  
  // for chaining
  return this;
}

/**
 * Remove the model.
 *
 * **Note:** this is a remotable instance method.
 */

Model.prototype.destroy = function (fn) {
  throw new Error('not implemented');
}
Model.prototype.destroy.remotable = true;

/**
 * Find by id.
 *
 * **Note:** this is a remotable static method.
 */

Model.findById = function (id, fn) {
  throw new Error('not implemented');
}
Model.findById.remotable = true;
Model.findById.accepts = [
  {arg: 'id', type: 'Number'}
];
Model.findById.returns = [
  {arg: 'model', type: 'this'}
];

/**
 * Find all models that match the given query.
 *
 * **Note:** this is a remotable static method.
 */

Model.all = function (query, fn) {
  if(typeof query === 'function') {
    fn = query;
    query = undefined;
  }
  
  throw new Error('not implemented');
}
Model.all.remotable = true;
Model.all.accepts = [
  {arg: 'query', type: 'Object', optional: true}
];
Model.all.returns = [
  {arg: 'models', type: ['this']}
];

/**
 * Count all models that match the given filter.
 *
 * **Note:** this is a remotable static method.
 */

Model.count = function (query, fn) {
  if(typeof query === 'function') {
    fn = query;
    query = undefined;
  }
  
  throw new Error('not implemented');
}
Model.all.remotable = true;
Model.all.accepts = [
  {arg: 'query', type: 'Object', optional: true}
];
Model.all.returns = [
  {arg: 'count', type: 'Number'}
];